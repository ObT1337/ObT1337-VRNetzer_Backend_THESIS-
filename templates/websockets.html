<!DOCTYPE html>
<html>
	<link rel="stylesheet" href="{{ url_for('static', filename='css/SwagStyle.css') }}"></link>

	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	</head>

<body>
<div>

<h5>Websockets</h5>

The VRNetzerWebApp is dynamic webpage but also a gameserver.<br> It keeps track of the gamestate and users, serves data and generates the user interfaces for multiple VRNetzer VRModules.
<br>It needs to update changes made by a user to an UI to all other connected clients so they reflect the same state. This is realized with SocketIO. It uses websockets to establish a bidirectional connection between the server and the clients.<br>
<br> 
<img src="{{ url_for('static', filename='img/help/socketio.jpg') }}" style="max-width: 100%;"><br>
This figure shows the steps involved for basic interactions, like a user changing a dropdown menu or clicking a button<br><br>



<h5>Server side</h5>
This is the python part around line 450<br><br>
app.py
<pre><code class="language-python">###SocketIO ROUTES###


    @socketio.on("join", namespace="/chat")
    def join(message):
        room = flask.session.get("room")
        join_room(room)
        print(
            bcolors.WARNING
            + flask.session.get("username")
            + " has entered the room."
            + bcolors.ENDC
        )
        emit(
            "status",
            {"msg": flask.session.get("username") + " has entered the room."},
            room=room,
        )
    
    
    @socketio.on("ex", namespace="/chat")
    def ex(message):
        room = flask.session.get("room")
        print(
            bcolors.WARNING
            + flask.session.get("username")
            + "ex: "
            + json.dumps(message)
            + bcolors.ENDC
        )
        message["usr"] = flask.session.get("username")
    
        if message["id"] == "projects":</code></pre>
It looks very similar to the flask routes with the difference that it misses the return and fires an emit function instead.<br>
This code sets up two endpoints on the serverside, the first for joining clients (1), and another called "ex" for all other data traffic.<br>
At the end, begining with the first if statment, starts the message routing code that decides what to do with each message (3) based on their"fn" and "id" fields.<br> Most of them will simply be relayed but some will create a different response.
<br><br>
<h5>Client side</h5>
On the client side, the connection is established on pageload (1). The code responsible for this is in /static/js/connect_socketIO_doku.js<br><br>
connect_socketIO_doku.js

<pre><code class="javascript">var socket;

    $(document).ready(function(){
        ///set up and connect to socket
        console.log('http://' + document.domain + ':' + location.port + '/chat');
        socket = io.connect('http://' + document.domain + ':' + location.port + '/chat');
        socket.io.opts.transports = ['websocket'];
        
        socket.on('connect', function() {
            socket.emit('join', {});
        });
        socket.on('status', function(data) {
        });
        socket.on('ex', function(data) {
            console.log("server returned: " + JSON.stringify(data));
            switch(data.fn)
            {
                case 'mkB':
                    makeButton(data.id, data.msg, data.msg);
                    break;</code></pre>
The switch function at the end again decides what happens depending on the incoming message (4).<br><br>
In /static/js/mc_UI_Elements.js are functions to set up basic UI elements that communicate their states over SocketIO.<br>
You can use them in Html to easily make multicasted User Interfaces.<br><br>
mc_UI_Elements.js
<pre><code class="javascript">function initDropdown(id, data, active) {

    $('#' + id).selectmenu();
  
    for (let i = 0; i < data.length; i++) {
    $('#' + id).append(new Option(data[i]));
    }
  
    $('#' + id).val(active);
    $('#' + id).selectmenu("refresh");
  
    $('#' + id).on('selectmenuselect', function() {
      var name = $('#' + id).find(':selected').text();
      socket.emit('ex', { id: id, opt: name, fn: "sel" });
      ///logger($('#selectMode').val());
    });
  
  }</code></pre>
  <br><br>


<h5>The message</h5>
Here is the JSON message that is emited when a dropdown is changed:<br><br>
<i>{"id":"projects","opt":"bunny","fn":"sel","usr":"2392"}</i><br><br>
Two fields are mandatory:<br>
- "fn" as in function, here what kind of UI element ("sel" for select, "btn" for button). It tells the server what to do with this message<br>
- "usr" the name of the sender<br><br>
The others change depending on "fn"<br>
- "id" the id of the html object (should be unique across the whole project)<br>
- "opt" the selected option
</div>

</body>
</html>